# Helper functions for fsbuild
# This file is automatically generated by fs-package

import datetime
import hashlib
import json
import locale
import os
import platform
import re
import subprocess
import sys
import time
import xml.etree.ElementTree
from os import path
from typing import Any, Dict, List, Optional


class PackageInformation:
    def __init__(self):
        self.values: Dict[str, str] = {}

    @property
    def bundle_id(self) -> str:
        return self.values.get(
            "PACKAGE_BUNDLE_ID", self.values.get("PACKAGE_MACOS_BUNDLE_ID", "")
        )

    @property
    def display_name(self) -> str:
        """E.g. FS-UAE Launcher."""
        return self.values.get("PACKAGE_DISPLAY_NAME", self.pretty_name)

    @property
    def name(self) -> str:
        """E.g. fs-uae-launcher."""
        return self.values["PACKAGE_NAME"]

    @property
    def pretty_name(self) -> str:
        """E.g. FS-UAE-Launcher."""
        return self.values["PACKAGE_NAME_PRETTY"]

    @property
    def type(self):
        return self.values["PACKAGE_TYPE"]

    @property
    def version(self):
        return self.values["PACKAGE_VERSION"]


_package_information: Optional[PackageInformation] = None


def check_notarization_result(request_uuid: str):
    for _ in range(60):
        time.sleep(10.0)
        result = run(
            [
                "xcrun",
                "altool",
                "--notarization-info",
                request_uuid,
                "-u",
                get_notarization_username(),
                "-p",
                "@env:NOTARIZATION_PASSWORD",
                "-itc_provider",
                get_notarization_itc_provider(),
                "--output-format",
                "xml",
            ]
        )
        if "<string>success</string>" in result:
            break
        elif "<string>in progress</string>" in result:
            print("in progress...")
            continue
        else:
            print(result)
            raise Exception("Unknown notarization result")
    else:
        raise Exception("Gave up notarization")


def get_package_information() -> PackageInformation:
    global _package_information
    if _package_information is None:
        _package_information = PackageInformation()
        with open("PACKAGE.FS", "r") as f:
            for line in f:
                try:
                    key, value = line.split("=", 1)
                    key = key.strip()
                    value = value.strip()
                    value = value.strip('"')
                    _package_information.values[key] = value
                except ValueError:
                    pass
    return _package_information


def get_app_name() -> str:
    return get_package_information().display_name + ".app"


def get_architecture() -> str:
    machine = platform.machine()
    if machine == "arm64":
        arch = "ARM64"
    else:
        arch = "x86-64"  # FIXME
    return arch


def get_bundle_name() -> str:
    package_information = get_package_information()
    if package_information.type == "fs-library-plugin":
        return get_framework_name()
    else:
        return get_app_name()


def get_bundle_path(prefix: str = "fsbuild/_build/") -> str:
    pretty_name = get_package_information().pretty_name
    bundle_name = get_bundle_name()
    arch = get_architecture()
    path = f"{prefix}{pretty_name}/macOS/{arch}/{bundle_name}"
    return path


def get_dmg_path() -> str:
    package_information = get_package_information()
    pretty_name = package_information.pretty_name
    version = package_information.version
    arch = get_architecture()
    os_dist = get_operating_system_dist()
    path = f"fsbuild/_dist/{pretty_name}_{version}_{os_dist}_{arch}.dmg"
    return path


def get_framework_name() -> str:
    return get_package_information().pretty_name + ".framework"


def get_notarization_itc_provider() -> str:
    return os.environ.get("NOTARIZATION_PROVIDER", "")


def get_notarization_username() -> str:
    return os.environ.get("NOTARIZATION_USERNAME", "")


def get_operating_system_dist() -> str:
    env_value = os.environ.get("SYSTEM_OS_DIST", "")
    if env_value:
        return env_value
    elif sys.platform == "linux":
        return "Linux"
    elif sys.platform == "darwin":
        return "macOS"
    elif sys.platform == "win32":
        return "Windows"
    return "Unknown"


def is_macos() -> bool:
    return sys.platform == "darwin"


def notarize_app(path_to_notarize: str, bundle_id: str) -> str:
    assert path.exists(path_to_notarize)
    print(f"Notarizing {path.basename(path_to_notarize)}")

    result = shell(
        "xcrun altool --notarize-app -t osx "
        "-f {path_to_notarize} "
        "--primary-bundle-id {bundle_id} "
        "-u {apple_id_user} "
        "-p @env:NOTARIZATION_PASSWORD "
        "-itc_provider {itc_provider} "
        "--output-format xml".format(
            apple_id_user=get_notarization_username(),
            bundle_id=bundle_id,
            itc_provider=get_notarization_itc_provider(),
            path_to_notarize=path_to_notarize,
        )
    )
    print(result)
    root = xml.etree.ElementTree.fromstring(result)
    dict_node = root.find("dict")
    assert dict_node is not None
    dict_node_2 = dict_node.find("dict")
    assert dict_node_2 is not None
    string_node = dict_node_2.find("string")
    assert string_node is not None
    request_uuid = string_node.text
    assert request_uuid
    print(request_uuid)
    return request_uuid


def run(args: List[str]) -> str:
    print(quote_args(args))
    # p = subprocess.Popen(args, stdout = subprocess.PIPE)
    # assert p.wait() == 0
    # assert p.stdout
    # output = p.stdout.read().decode("UTF-8")
    # assert p.wait() == 0
    # return output
    return subprocess.check_output(args).decode("UTF-8")


def run_codesign(args: List[str]) -> None:
    # Signing sometimes fails due to Apple errors (timeouts, etc). So we try
    # multiple times before giving up.
    for i in range(20):
        try:
            shell(quote_args(args))
        except Exception:
            time.sleep(1.0 * i)
            print("Attempt", i + 2)
        else:
            break
    else:
        raise Exception("Giving up signing")


def quote_arg(arg: str) -> str:
    if " " in arg:
        return f'"{arg}"'
    return arg


def quote_args(args: List[str]) -> str:
    return " ".join(f"{quote_arg(a)}" for a in args)


def shell(cmd: str) -> str:
    print(cmd)
    return subprocess.run(
        cmd, shell=True, check=True, stdout=subprocess.PIPE
    ).stdout.decode("UTF-8")


class Version:
    def __init__(self, version: str) -> None:
        self.version = version
        m = re.match("([0-9.]+[0-9])(.*)", version)
        assert m is not None
        parts = m.group(1).split(".")
        assert 2 <= len(parts) <= 4
        self.major = int(parts[0])
        self.minor = int(parts[1])
        self.build: Optional[int]
        if len(parts) > 3:
            self.build = int(parts[3])
        else:
            self.build = None
        if len(parts) > 2:
            self.revision = int(parts[2])
        else:
            self.revision = 0
        self.tag = m.group(2)
        self.commit = ""

    def set_last(self, n: int) -> None:
        if self.build is not None:
            self.build = n
        else:
            self.revision = n

    def __str__(self) -> str:
        numbers = [self.major, self.minor, self.revision]
        if self.build is not None:
            numbers.append(self.build)
        version = ".".join(str(x) for x in numbers)
        return version + self.tag


def num_commits_since(base: str) -> int:
    to = "HEAD"
    result = int(
        subprocess.check_output(
            ["git", "rev-list", f"{base}..{to}", "--count"]
        ).decode()
    )
    return result


def find_last_commit_for_file(path: str) -> str:
    commit = subprocess.check_output(
        ["git", "log", "-n", "1", "--pretty=format:%H", "--", path]
    ).decode()
    return commit


def find_last_commit() -> str:
    commit = subprocess.check_output(
        ["git", "log", "-n", "1", "--pretty=format:%H"]
    ).decode()
    return commit


def update_configure_ac(version: Version, commit: str = "") -> None:
    print("Updating configure.ac")
    lines: List[str] = []
    with open("configure.ac", "r", encoding="UTF-8") as f:
        for line in f:
            if line.startswith("m4_define([fsbuild_version"):
                if "_major" in line:
                    k = "FSBUILD_VERSION_MAJOR"
                    v = str(version.major)
                    # d = "Major version"
                elif "_minor" in line:
                    k = "FSBUILD_VERSION_MINOR"
                    v = str(version.minor)
                    # d = "Minor version"
                elif "_revision" in line:
                    k = "FSBUILD_VERSION_REVISION"
                    v = str(version.revision)
                    # d = "Revision"
                else:
                    k = "FSBUILD_VERSION"
                    v = str(version)
                    # d = "Full version"
                line = "m4_define([{}], [{}])\n".format(k.lower(), v)
            # if line.startswith("AC_DEFINE_UNQUOTED([FSBUILD_VERSION"):
            #     if "_MAJOR" in line:
            #         k = "FSBUILD_VERSION_MAJOR"
            #         v = version.major
            #         d = "Major version"
            #     elif "_MINOR" in line:
            #         k = "FSBUILD_VERSION_MINOR"
            #         v = version.minor
            #         d = "Minor version"
            #     elif "_REVISION" in line:
            #         k = "FSBUILD_VERSION_REVISION"
            #         v = version.revision
            #         d = "Revision"
            #     else:
            #         k = "FSBUILD_VERSION"
            #         v = str(version)
            #         d = "Full version"
            #     line = "AC_DEFINE_UNQUOTED([{}], [{}], [{}])\n".format(k, v, d)
            if line.startswith("m4_define([fsbuild_commit"):
                line = "m4_define([{}], [{}])\n".format(
                    "fsbuild_commit", commit
                )
            # if line.startswith("AC_DEFINE_UNQUOTED([FSBUILD_COMMIT"):
            #     k = "FSBUILD_COMMIT"
            #     v = commit
            #     d = "Package commit"
            #     line = "AC_DEFINE_UNQUOTED([{}], [{}], [{}])\n".format(k, v, d)
            lines.append(line)
    with open("configure.ac", "w", encoding="UTF-8") as f:
        for line in lines:
            f.write(line)


def update_debian_changelog(version: Version) -> None:
    print("Updating debian/changelog")
    lines: List[str] = []
    first_line = True
    first_line_changed = False
    deb_package = "unknown"
    deb_version = str(version)
    # deb_version = deb_version.replace("alpha", "~alpha")
    # deb_version = deb_version.replace("beta", "~beta")
    # deb_version = deb_version.replace("dev", "~dev")
    with open("debian/changelog", "r", encoding="UTF-8") as f:
        for line in f:
            if first_line:
                first_line = False
                deb_package = line.split(" ", 1)[0]
                lines.append(
                    "{} ({}-0) unstable; urgency=low\n".format(
                        deb_package, deb_version
                    )
                )
                if lines[-1] != line:
                    first_line_changed = True
            elif line.startswith(" -- ") and first_line_changed:
                # Only update date if version was changed
                author, date = line.split("  ")
                date = datetime.datetime.utcnow().strftime(
                    "%a, %d %b %Y %H:%M:%S +0000"
                )
                lines.append("{}  {}\n".format(author, date))
            else:
                lines.append(line)
    with open("debian/changelog", "w", encoding="UTF-8") as f:
        for line in lines:
            f.write(line)


def update_spec_file(path: str, version: Version) -> None:
    print("Updating", path)
    lines: List[str] = []
    rpm_version = str(version)
    # rpm_version = rpm_version.replace("alpha", "-0.1alpha")
    # rpm_version = rpm_version.replace("beta", "-0.1~beta")
    # rpm_version = rpm_version.replace("dev", "-0.1dev")
    # if not "-" in rpm_version:
    #     rpm_version += "-1"
    with open(path, "r", encoding="UTF-8") as f:
        for line in f:
            if line.startswith("%define fsbuild_version "):
                lines.append(
                    "%define fsbuild_version {}\n".format(rpm_version)
                )
            # elif line.startswith("%define unmangled_version "):
            #     lines.append("%define unmangled_version {0}\n".format(version))
            else:
                lines.append(line)
    with open(path, "w", newline="\n") as f:
        f.write("".join(lines))


def update_package_fs(version: Version) -> None:
    print("Updating PACKAGE.FS")
    lines: List[str] = []
    with open("PACKAGE.FS", "r", encoding="UTF-8") as f:
        for line in f:
            if line.startswith("PACKAGE_VERSION="):
                lines.append(f"PACKAGE_VERSION={str(version)}\n")
            elif line.startswith("PACKAGE_VERSION_MAJOR="):
                lines.append(f"PACKAGE_VERSION_MAJOR={str(version.major)}\n")
            elif line.startswith("PACKAGE_VERSION_MINOR="):
                lines.append(f"PACKAGE_VERSION_MINOR={str(version.minor)}\n")
            elif line.startswith("PACKAGE_VERSION_REVISION="):
                lines.append(
                    f"PACKAGE_VERSION_REVISION={str(version.revision)}\n"
                )
            elif line.startswith("PACKAGE_VERSION_TAG="):
                lines.append(f"PACKAGE_VERSION_TAG={str(version.tag)}\n")
            elif line.startswith("PACKAGE_COMMIT="):
                lines.append(f"PACKAGE_COMMIT={version.commit}\n")
            else:
                lines.append(line)
    with open("PACKAGE.FS", "w", newline="\n") as f:
        f.write("".join(lines))


def update_version_fs(version: Version) -> None:
    print("Updating VERSION.FS")
    with open("VERSION.FS", "w") as f:
        f.write(str(version))
        f.write("\n")


def update_commit_fs(version: Version) -> None:
    print("Updating COMMIT.FS")
    with open("COMMIT.FS", "w") as f:
        if version.commit:
            f.write(version.commit)
            f.write("\n")


def calculate_version(
    auto_revision: bool = False,
    increment_revision: bool = False,
    include_commit: bool = False,
) -> Version:
    # with open("fsbuild/VERSION") as f:
    with open("BASEVERSION.FS") as f:
        version_str = f.read().strip()
    if version_str.startswith("BASEVERSION_FS="):
        version_str = version_str[len("BASEVERSION_FS=") :].strip()
    # with open("PACKAGE.FS") as f:
    #     for line in f:
    #         if line.startswith("PACKAGE_VERSION="):
    #             version_str = line[16:].strip()
    version = Version(version_str)
    if auto_revision:
        version_commit = find_last_commit_for_file("BASEVERSION.FS")
        increment = num_commits_since(version_commit)
        if increment_revision:
            increment += 1
        if version.build is not None:
            version.build += increment
        else:
            version.revision += increment
    if "--commit" in sys.argv:
        version.commit = find_last_commit()

    if True:
        branch = None
        github_ref = os.environ.get("GITHUB_REF")
        if github_ref is not None:
            if github_ref.startswith("refs/heads/"):
                branch = github_ref[len("refs/heads/") :]
            if github_ref.startswith("refs/pull/"):
                branch = "pull" + github_ref[len("refs/pull/") :].replace(
                    "/", ""
                )
        if not branch:
            branch = subprocess.check_output(
                ["git", "symbolic-ref", "--short", "HEAD"], encoding="UTF-8"
            ).strip()

        if branch == "stable":
            version.tag = ""
        elif branch:
            version.tag = f"-{branch}"
        else:
            raise Exception("Cannot calculate version tag from git ref")

    return version


def update_version(version: Version) -> None:
    if os.path.exists("VERSION.FS"):
        update_version_fs(version)
    if os.path.exists("COMMIT.FS"):
        update_commit_fs(version)
    if os.path.exists("configure.ac"):
        update_configure_ac(version)
    if os.path.exists("debian/changelog"):
        update_debian_changelog(version)
    if os.path.exists("PACKAGE.FS"):
        update_package_fs(version)
    for filename in os.listdir("."):
        if filename.endswith(".spec"):
            update_spec_file(filename, version)


def version_main() -> None:
    # For date/time formatting
    locale.setlocale(locale.LC_TIME, "C")

    # auto_revision = "--auto" in sys.argv
    auto_revision = True
    increment_revision = "--next" in sys.argv
    # include_commit = "--commit" in sys.argv
    include_commit = True
    # if "--auto-next" in sys.argv:
    #     auto_revision = True
    #     increment_revision = True
    version = calculate_version(
        auto_revision=auto_revision,
        increment_revision=increment_revision,
        include_commit=include_commit,
    )
    for arg in sys.argv:
        if arg.startswith("--build="):
            version.build = int(arg[8:])
        elif arg.startswith("--revision="):
            version.revision = int(arg[11:])
        elif arg.startswith("--last="):
            version.set_last(int(arg[7:]))
    print(str(version))
    if "--print" in sys.argv:
        # Only print version
        pass
    else:
        update_version(version)


def build_dmg_main():
    if not is_macos():
        print("Not building DMG on non-macOS platform")
        return
    dmg_path = get_dmg_path()
    bundle_path = get_bundle_path()
    package_information = get_package_information()
    print(f"Building {path.basename(dmg_path)}")
    if not path.exists(path.dirname(dmg_path)):
        os.makedirs(path.dirname(dmg_path))
    if os.path.exists(dmg_path):
        os.unlink(dmg_path)
    tool = "appdmg"
    if tool == "appdmg":
        bundle_path = get_bundle_path(prefix="")
        settings_path = "fsbuild/_build/appdmg.json"
        with open(settings_path, "w", encoding="UTF-8") as f:
            json.dump(
                {
                    "title": package_information.display_name,
                    "contents": [
                        {
                            "x": 192,
                            "y": 344,
                            "type": "file",
                            "path": bundle_path,
                        },
                        {
                            "x": 448,
                            "y": 344,
                            "type": "link",
                            "path": "/Applications",
                        },
                    ],
                },
                f,
            )
        subprocess.check_call(
            [
                "appdmg",
                settings_path,
                dmg_path,
            ]
        )
    elif tool == "dmgbuild":  # type: ignore
        bundle_path = get_bundle_path()
        settings_path = "fsbuild/_build/dmgbuild-settings.py"
        with open(settings_path, "w", encoding="UTF-8") as f:
            f.write("format = 'UDZO'\n")
            f.write("files = [\n")
            f.write(f"    '{bundle_path}',\n")
            f.write("]\n")
            f.write("symlinks = { 'Applications': '/Applications' }\n")
            f.write("badge_icon = 'icon/fs-uae-launcher.icns'\n")
        subprocess.check_call(
            [
                "dmgbuild",
                "-s",
                settings_path,
                "FS-UAE-Launcher",
                dmg_path,
            ]
        )
    else:
        raise Exception("Unknown dmg builder")


def sign_main():
    if get_package_information().type == "fs-data-plugin":
        print("Not signing data plugin")
    elif is_macos():
        args = [
            "codesign",
            "--force",
            "--deep",
            "--options",
            "runtime",
            "--sign",
            "Developer ID Application",
            "--digest-algorithm=sha1,sha256",
        ]
        if os.path.exists("fsbuild/Entitlements.plist"):
            args.extend(["--entitlements", "fsbuild/Entitlements.plist"])
        args.append(get_bundle_path())
        run_codesign(args)
    else:
        print("Skipping sign step (no signatures for this platform)")


def sign_dmg_main():
    if not is_macos():
        print("Not signing DMG on non-macOS platform")
        return
    args = [
        "codesign",
        "--force",
        "--sign",
        "Developer ID Application",
        "--digest-algorithm=sha1,sha256",
    ]
    args.append(get_dmg_path())
    run_codesign(args)


def notarize_for_macos():
    bundle_id = get_package_information().bundle_id
    bundle_path = get_bundle_path()
    bundle_name = os.path.basename(bundle_path)
    bundle_parent_dir = os.path.dirname(bundle_path)
    shell("rm -f fsbuild/_build/notarize.zip")
    zip = "../../../notarize.zip"
    shell(
        f'cd {bundle_parent_dir} && ditto -c -k --keepParent "{bundle_name}" "{zip}"'
    )
    request_uuid = notarize_app("fsbuild/_build/notarize.zip", bundle_id)
    check_notarization_result(request_uuid)

    if bundle_path.endswith(".framework"):
        print(
            "Does not seem to be possible to staple tickets to frameworks? (error 73)"
        )
        print("Exiting...")
        sys.exit(0)

    run(["xcrun", "stapler", "staple", bundle_path])


def notarize_main():
    if get_package_information().type == "fs-data-plugin":
        print("Not notarizing data plugin")
    elif is_macos():
        notarize_for_macos()
    else:
        print("Skipping sign step (no signatures for this platform)")


def notarize_dmg_main():
    if not is_macos():
        print("Not notarizing DMG on non-macOS platform")
        return
    package_information = get_package_information()
    bundle_id = package_information.bundle_id
    dmg_path = get_dmg_path()
    assert path.exists(dmg_path)
    request_uuid = notarize_app(dmg_path, bundle_id)
    check_notarization_result(request_uuid)

    print('xcrun stapler staple "{}"'.format(dmg_path))
    assert os.system('xcrun stapler staple "{}"'.format(dmg_path)) == 0

    print("-" * 80)
    print(f"[FSBUILD] Notarized {dmg_path}")


def verify_download(archive: str, h: Any, checksum: str) -> bool:
    with open(archive, "rb") as f:
        actual_checksum = h(f.read()).hexdigest()
    result = actual_checksum == checksum
    if result:
        print("Checksum verified")
    else:
        print("Checksum verification failed")
        print("Expected", checksum)
        print("But got:", actual_checksum)
    return result


def download_main():
    url = sys.argv[1]
    checksum = sys.argv[2]
    if checksum.startswith("sha256:"):
        h = hashlib.sha256
        checksum = checksum[7:]
    else:
        raise Exception("Unknown hash function")
    archive = url.split("/")[-1]
    if not os.path.exists("fsbuild/_sources"):
        os.makedirs("fsbuild/_sources")
    archive = os.path.join("fsbuild/_sources", archive)
    if os.path.exists(archive):
        if verify_download(archive, h, checksum):
            sys.exit(0)
        print("Removing archive", archive)
        os.remove(archive)
    # FIXME: Replace use of wget, just use python instead
    if os.system(f'cd fsbuild/_sources && wget "{url}"') != 0:
        print("Failed to download")
        sys.exit(1)
    if not verify_download(archive, h, checksum):
        sys.exit(2)


def execute_discord_webhook(name: str, link: str) -> None:
    import requests

    webhook_url = os.getenv("DISCORD_WEBHOOK_URL")
    if not webhook_url:
        return
    content = (
        f"`{name}` was built and uploaded to a Dropbox "
        f"[shared folder]({link})"
    )
    requests.post(webhook_url, {"content": content, "username": "Builder"})


def get_upload_branch_name() -> Optional[str]:
    ref = os.getenv("GITHUB_REF", "")
    try:
        branch = ref.split("refs/heads/", 1)[1]
    except IndexError:
        return None
    if "/" in branch:
        return None
    return branch[0].upper() + branch[1:]


def upload(package: str, version: str, path: str) -> None:
    import dropbox  # type: ignore

    dbx: Any = dropbox.Dropbox(os.getenv("DROPBOX_ACCESS_TOKEN"))  # type: ignore
    print("Upload", path)
    name = os.path.basename(path)
    assert package.lower() in name.lower()
    assert version in name
    branch = get_upload_branch_name()
    if not branch:
        print("No upload branch name, skipping upload")
        return
    dst = f"/Builds/CI/{package}/{branch}/{version}/{name}"
    with open(path, "rb") as f:
        dbx.files_upload(f.read(), dst)
    print("Uploaded ->", dst)
    if os.getenv("DISCORD_WEBHOOK_URL"):
        result: Any = dbx.sharing_list_shared_links(f"/Builds/CI/{package}")
        for link in result.links:
            if link.path_lower == f"/Builds/CI/{package}".lower():
                url = link.url
                print("Found Dropbox shared link:", url)
                break
        else:
            # Fallback URL, use first result returned
            url = result.links[0].url
            print("Found Dropbox shared (fallback) link:", url)
        execute_discord_webhook(name, url)


def upload_main():
    dist_dir = "fsbuild/_dist"
    upload_items = os.listdir(dist_dir)
    package = get_package_information()
    for item in upload_items:
        upload(
            package.pretty_name,
            package.version,
            os.path.join(dist_dir, item),
        )


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Missing command")
        sys.exit(1)
    elif sys.argv[1] == "build-dmg":
        build_dmg_main()
    elif sys.argv[1] == "download":
        download_main()
    elif sys.argv[1] == "notarize":
        notarize_main()
    elif sys.argv[1] == "notarize-dmg":
        notarize_dmg_main()
    elif sys.argv[1] == "sign":
        sign_main()
    elif sys.argv[1] == "sign-dmg":
        sign_dmg_main()
    elif sys.argv[1] == "upload":
        upload_main()
    elif sys.argv[1] == "version":
        version_main()
    else:
        print("Unknown command")
        sys.exit(1)
